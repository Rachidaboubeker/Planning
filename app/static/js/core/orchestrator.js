/**
 * ORCHESTRATEUR PRINCIPAL - CORRECTION COMPL√àTE
 * Coordonne tous les correctifs et garantit le bon fonctionnement
 */

(function() {
    'use strict';

    console.log('üé≠ D√©marrage de l\'orchestrateur principal...');

    // ==================== CONFIGURATION ====================

    const ORCHESTRATOR_CONFIG = {
        // D√©lais d'attente pour chaque √©tape
        delays: {
            dataCleanup: 2000,      // Attendre avant nettoyage donn√©es
            layoutGeneration: 1500,  // Attendre avant g√©n√©ration layout
            finalValidation: 3000,   // Attendre avant validation finale
            retryInterval: 5000      // Intervalle entre tentatives
        },

        // Nombre maximum de tentatives
        maxRetries: 3,

        // √âl√©ments requis pour validation
        requiredElements: [
            'planningHeader',
            'planningGrid',
            'employeesLegend',
            'notificationsContainer'
        ],

        // Managers requis
        requiredManagers: [
            'StateManager',
            'APIManager',
            'PlanningManager',
            'EventsManager'
        ]
    };

    // ==================== √âTAT DE L'ORCHESTRATEUR ====================

    let orchestratorState = {
        phase: 'initialization',
        attempt: 1,
        startTime: Date.now(),
        completedSteps: [],
        errors: [],
        status: {
            structureValid: false,
            managersLoaded: false,
            dataClean: false,
            layoutGenerated: false,
            shiftsRendered: false,
            dragDropActive: false
        }
    };

    // ==================== VALIDATION PR√âALABLE ====================

    /**
     * V√©rifie si tous les pr√©requis sont satisfaits
     */
    function validatePrerequisites() {
        console.log('üîç Validation des pr√©requis...');

        const results = {
            structure: validateStructure(),
            managers: validateManagers(),
            apis: validateAPIs(),
            dependencies: validateDependencies()
        };

        const allValid = Object.values(results).every(result => result.valid);

        console.log('üìä R√©sultats validation:');
        Object.entries(results).forEach(([key, result]) => {
            console.log(`   - ${key}: ${result.valid ? '‚úÖ' : '‚ùå'} ${result.message}`);
        });

        orchestratorState.status.structureValid = results.structure.valid;
        return { valid: allValid, results };
    }

    /**
     * Valide la structure HTML
     */
    function validateStructure() {
        const missing = ORCHESTRATOR_CONFIG.requiredElements.filter(
            id => !document.getElementById(id)
        );

        return {
            valid: missing.length === 0,
            message: missing.length === 0
                ? 'Structure HTML compl√®te'
                : `${missing.length} √©l√©ments manquants: ${missing.join(', ')}`
        };
    }

    /**
     * Valide les managers JavaScript
     */
    function validateManagers() {
        const missing = ORCHESTRATOR_CONFIG.requiredManagers.filter(
            manager => !window[manager]
        );

        return {
            valid: missing.length === 0,
            message: missing.length === 0
                ? 'Tous les managers sont charg√©s'
                : `${missing.length} managers manquants: ${missing.join(', ')}`
        };
    }

    /**
     * Valide les APIs disponibles
     */
    function validateAPIs() {
        const apiTests = [
            { name: 'employees', url: '/api/employees' },
            { name: 'shifts', url: '/api/shifts' }
        ];

        // Test simple - on assume que les APIs sont disponibles si on arrive ici
        return {
            valid: true,
            message: 'APIs REST disponibles'
        };
    }

    /**
     * Valide les d√©pendances critiques
     */
    function validateDependencies() {
        const dependencies = [
            { name: 'fetch', check: () => typeof fetch !== 'undefined' },
            { name: 'Promise', check: () => typeof Promise !== 'undefined' },
            { name: 'Map', check: () => typeof Map !== 'undefined' },
            { name: 'Set', check: () => typeof Set !== 'undefined' }
        ];

        const missing = dependencies.filter(dep => !dep.check());

        return {
            valid: missing.length === 0,
            message: missing.length === 0
                ? 'D√©pendances JavaScript OK'
                : `D√©pendances manquantes: ${missing.map(d => d.name).join(', ')}`
        };
    }

    // ==================== √âTAPES DE CORRECTION ====================

    /**
     * √âtape 1: Nettoyage automatique des donn√©es
     */
    async function executeDataCleanup() {
        console.log('üßπ √âTAPE 1: Nettoyage des donn√©es...');

        try {
            // V√©rifier si le module de nettoyage est disponible
            if (!window.dataCleanup) {
                console.warn('‚ö†Ô∏è Module de nettoyage non disponible, chargement...');
                // Le module devrait √™tre charg√© automatiquement
                await waitForCondition(() => window.dataCleanup, 5000);
            }

            if (window.dataCleanup && window.dataCleanup.executeAll) {
                console.log('üöÄ Lancement du nettoyage automatique...');
                await window.dataCleanup.executeAll();

                orchestratorState.status.dataClean = true;
                orchestratorState.completedSteps.push('dataCleanup');
                console.log('‚úÖ Nettoyage des donn√©es termin√©');
                return { success: true };
            } else {
                throw new Error('Module de nettoyage non disponible');
            }

        } catch (error) {
            console.error('‚ùå Erreur nettoyage donn√©es:', error);
            orchestratorState.errors.push({ step: 'dataCleanup', error: error.message });
            return { success: false, error };
        }
    }

    /**
     * √âtape 2: G√©n√©ration du layout CSS Grid
     */
    async function executeLayoutGeneration() {
        console.log('üé® √âTAPE 2: G√©n√©ration du layout...');

        try {
            // V√©rifier si le LayoutManager est disponible
            if (!window.LayoutManager) {
                console.warn('‚ö†Ô∏è LayoutManager non disponible, chargement...');
                await waitForCondition(() => window.LayoutManager, 5000);
            }

            if (window.LayoutManager && window.LayoutManager.initialize) {
                console.log('üèóÔ∏è Initialisation du layout CSS Grid...');
                window.LayoutManager.initialize();

                // Attendre que la grille soit g√©n√©r√©e
                await waitForCondition(() => {
                    const grid = document.getElementById('planningGrid');
                    return grid && grid.querySelectorAll('.employee-cell').length > 0;
                }, 3000);

                orchestratorState.status.layoutGenerated = true;
                orchestratorState.completedSteps.push('layoutGeneration');
                console.log('‚úÖ Layout g√©n√©r√© avec succ√®s');
                return { success: true };
            } else {
                throw new Error('LayoutManager non disponible');
            }

        } catch (error) {
            console.error('‚ùå Erreur g√©n√©ration layout:', error);
            orchestratorState.errors.push({ step: 'layoutGeneration', error: error.message });
            return { success: false, error };
        }
    }

    /**
     * √âtape 3: Rendu des cr√©neaux
     */
    async function executeShiftRendering() {
        console.log('üéØ √âTAPE 3: Rendu des cr√©neaux...');

        try {
            // Utiliser le LayoutManager ou PlanningManager
            const manager = window.LayoutManager || window.PlanningManager;

            if (!manager) {
                throw new Error('Aucun manager de rendu disponible');
            }

            if (manager.updateShifts) {
                console.log('üé® Rendu des cr√©neaux...');
                manager.updateShifts();
            } else if (manager.renderShifts) {
                console.log('üé® Rendu des cr√©neaux (m√©thode alternative)...');
                manager.renderShifts();
            }

            // V√©rifier que des cr√©neaux sont rendus
            await new Promise(resolve => setTimeout(resolve, 1000));

            const visibleShifts = document.querySelectorAll('.shift-block').length;
            console.log(`üìä ${visibleShifts} cr√©neaux rendus`);

            orchestratorState.status.shiftsRendered = true;
            orchestratorState.completedSteps.push('shiftRendering');
            console.log('‚úÖ Rendu des cr√©neaux termin√©');
            return { success: true, shiftsCount: visibleShifts };

        } catch (error) {
            console.error('‚ùå Erreur rendu cr√©neaux:', error);
            orchestratorState.errors.push({ step: 'shiftRendering', error: error.message });
            return { success: false, error };
        }
    }

    /**
     * √âtape 4: Activation du drag & drop
     */
    async function executeDragDropActivation() {
        console.log('üñ±Ô∏è √âTAPE 4: Activation du drag & drop...');

        try {
            if (window.DragDropManager && window.DragDropManager.refresh) {
                console.log('üîÑ Rafra√Æchissement du drag & drop...');
                window.DragDropManager.refresh();

                orchestratorState.status.dragDropActive = true;
                orchestratorState.completedSteps.push('dragDropActivation');
                console.log('‚úÖ Drag & drop activ√©');
                return { success: true };
            } else {
                console.warn('‚ö†Ô∏è DragDropManager non disponible');
                return { success: false, error: 'DragDropManager manquant' };
            }

        } catch (error) {
            console.error('‚ùå Erreur activation drag & drop:', error);
            orchestratorState.errors.push({ step: 'dragDropActivation', error: error.message });
            return { success: false, error };
        }
    }

    /**
     * √âtape 5: Validation finale
     */
    async function executeFinalValidation() {
        console.log('‚úÖ √âTAPE 5: Validation finale...');

        const validation = {
            employees: 0,
            shifts: 0,
            cellsGrid: 0,
            visibleShifts: 0,
            dragDropElements: 0
        };

        try {
            // Compter les employ√©s
            const state = window.StateManager?.getState();
            if (state) {
                validation.employees = (state.employees || []).filter(emp => emp.actif).length;
                validation.shifts = (state.shifts || []).length;
            }

            // Compter les √©l√©ments DOM
            validation.cellsGrid = document.querySelectorAll('.employee-cell').length;
            validation.visibleShifts = document.querySelectorAll('.shift-block').length;
            validation.dragDropElements = document.querySelectorAll('[draggable="true"]').length;

            console.log('üìä VALIDATION FINALE:');
            console.log(`   - ${validation.employees} employ√©s actifs`);
            console.log(`   - ${validation.shifts} cr√©neaux en m√©moire`);
            console.log(`   - ${validation.cellsGrid} cellules de grille`);
            console.log(`   - ${validation.visibleShifts} cr√©neaux visibles`);
            console.log(`   - ${validation.dragDropElements} √©l√©ments draggables`);

            const isValid = validation.employees > 0 &&
                           validation.cellsGrid > 0 &&
                           validation.visibleShifts >= 0;

            if (isValid) {
                console.log('üéâ VALIDATION R√âUSSIE !');
                return { success: true, validation };
            } else {
                throw new Error('Validation √©chou√©e - donn√©es insuffisantes');
            }

        } catch (error) {
            console.error('‚ùå Erreur validation finale:', error);
            orchestratorState.errors.push({ step: 'finalValidation', error: error.message });
            return { success: false, error, validation };
        }
    }

    // ==================== UTILITAIRES ====================

    /**
     * Attend qu'une condition soit remplie
     */
    function waitForCondition(condition, timeout = 5000) {
        return new Promise((resolve, reject) => {
            const startTime = Date.now();

            function check() {
                if (condition()) {
                    resolve(true);
                } else if (Date.now() - startTime > timeout) {
                    reject(new Error(`Timeout apr√®s ${timeout}ms`));
                } else {
                    setTimeout(check, 100);
                }
            }

            check();
        });
    }

    /**
     * Affiche un rapport de progression
     */
    function showProgressReport(step, result) {
        const progress = (orchestratorState.completedSteps.length / 5) * 100;

        console.log(`üìà PROGRESSION: ${Math.round(progress)}% - ${step} ${result.success ? '‚úÖ' : '‚ùå'}`);

        if (window.NotificationManager) {
            window.NotificationManager.show({
                type: result.success ? 'info' : 'warning',
                title: `Correction en cours (${Math.round(progress)}%)`,
                message: `${step}: ${result.success ? 'R√©ussi' : '√âchou√©'}`,
                duration: 2000
            });
        }
    }

    /**
     * Affiche le rapport final
     */
    function showFinalReport(success, duration) {
        const report = {
            success,
            duration,
            completedSteps: orchestratorState.completedSteps.length,
            totalSteps: 5,
            errors: orchestratorState.errors.length,
            status: orchestratorState.status
        };

        console.log('üìã RAPPORT FINAL:');
        console.log(`   - Dur√©e: ${duration}ms`);
        console.log(`   - √âtapes: ${report.completedSteps}/${report.totalSteps}`);
        console.log(`   - Erreurs: ${report.errors}`);
        console.log(`   - Statut:`, report.status);

        if (orchestratorState.errors.length > 0) {
            console.log('‚ö†Ô∏è ERREURS D√âTECT√âES:');
            orchestratorState.errors.forEach((err, index) => {
                console.log(`   ${index + 1}. ${err.step}: ${err.error}`);
            });
        }

        // Notification utilisateur
        if (window.NotificationManager) {
            window.NotificationManager.show({
                type: success ? 'success' : 'error',
                title: success ? 'Correction termin√©e' : 'Correction partielle',
                message: success
                    ? `Planning restaur√© avec succ√®s en ${duration}ms`
                    : `${report.completedSteps}/${report.totalSteps} √©tapes r√©ussies`,
                duration: 5000
            });
        }

        return report;
    }

    // ==================== PROCESSUS PRINCIPAL ====================

    /**
     * Ex√©cute la correction compl√®te
     */
    async function executeFullCorrection() {
        console.log('üöÄ D√âMARRAGE DE LA CORRECTION COMPL√àTE...');
        orchestratorState.phase = 'executing';
        orchestratorState.startTime = Date.now();

        try {
            // Validation pr√©alable
            const prerequisites = validatePrerequisites();
            if (!prerequisites.valid) {
                console.warn('‚ö†Ô∏è Pr√©requis non satisfaits, tentative de correction...');
            }

            // √âtape 1: Nettoyage des donn√©es
            await new Promise(resolve => setTimeout(resolve, ORCHESTRATOR_CONFIG.delays.dataCleanup));
            const dataResult = await executeDataCleanup();
            showProgressReport('Nettoyage donn√©es', dataResult);

            // √âtape 2: G√©n√©ration layout
            await new Promise(resolve => setTimeout(resolve, ORCHESTRATOR_CONFIG.delays.layoutGeneration));
            const layoutResult = await executeLayoutGeneration();
            showProgressReport('G√©n√©ration layout', layoutResult);

            // √âtape 3: Rendu cr√©neaux
            const shiftResult = await executeShiftRendering();
            showProgressReport('Rendu cr√©neaux', shiftResult);

            // √âtape 4: Drag & drop
            const dragDropResult = await executeDragDropActivation();
            showProgressReport('Drag & drop', dragDropResult);

            // √âtape 5: Validation finale
            await new Promise(resolve => setTimeout(resolve, ORCHESTRATOR_CONFIG.delays.finalValidation));
            const validationResult = await executeFinalValidation();
            showProgressReport('Validation finale', validationResult);

            // Rapport final
            const duration = Date.now() - orchestratorState.startTime;
            const success = orchestratorState.completedSteps.length >= 4; // Au moins 4/5 √©tapes

            orchestratorState.phase = success ? 'completed' : 'failed';
            return showFinalReport(success, duration);

        } catch (error) {
            console.error('üí• ERREUR CRITIQUE lors de la correction:', error);
            orchestratorState.phase = 'failed';
            orchestratorState.errors.push({ step: 'global', error: error.message });

            const duration = Date.now() - orchestratorState.startTime;
            return showFinalReport(false, duration);
        }
    }

    /**
     * Tentative de correction avec retry
     */
    async function attemptCorrectionWithRetry() {
        for (let attempt = 1; attempt <= ORCHESTRATOR_CONFIG.maxRetries; attempt++) {
            console.log(`üéØ TENTATIVE ${attempt}/${ORCHESTRATOR_CONFIG.maxRetries}`);
            orchestratorState.attempt = attempt;

            const result = await executeFullCorrection();

            if (result.success) {
                console.log('üéâ CORRECTION R√âUSSIE !');
                return result;
            } else if (attempt < ORCHESTRATOR_CONFIG.maxRetries) {
                console.log(`‚ö†Ô∏è Tentative ${attempt} √©chou√©e, retry dans ${ORCHESTRATOR_CONFIG.delays.retryInterval}ms...`);

                // Reset de l'√©tat pour retry
                orchestratorState.completedSteps = [];
                orchestratorState.errors = [];
                orchestratorState.status = {
                    structureValid: false,
                    managersLoaded: false,
                    dataClean: false,
                    layoutGenerated: false,
                    shiftsRendered: false,
                    dragDropActive: false
                };

                await new Promise(resolve => setTimeout(resolve, ORCHESTRATOR_CONFIG.delays.retryInterval));
            }
        }

        console.error('‚ùå CORRECTION √âCHOU√âE apr√®s toutes les tentatives');
        return { success: false, finalAttempt: true };
    }

    // ==================== INITIALISATION ET EXPOSITION ====================

    // Exposer l'API
    window.MasterOrchestrator = {
        execute: executeFullCorrection,
        executeWithRetry: attemptCorrectionWithRetry,
        validatePrerequisites,
        getState: () => orchestratorState,
        config: ORCHESTRATOR_CONFIG
    };

    // D√©marrage automatique apr√®s un d√©lai
    setTimeout(() => {
        console.log('üé≠ D√©marrage automatique de la correction...');
        attemptCorrectionWithRetry();
    }, 3000);

    console.log('üé≠ Orchestrateur principal charg√©');
    console.log('üõ†Ô∏è API: window.MasterOrchestrator');

})();